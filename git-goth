#!/bin/bash

[ $(uname) = "Linux" ] && sedRegExp="-r" || sedRegExp="-E"

function latest_rc_tags()
{
	case $1 in
		-[0-9]*) limit=$1;;
		[0-9]*) limit=-$1;;
		*)      limit=-1;;
	esac
	for i in "^maintenance_2012.." "^REL_.*_RC\$" "^tags/([0-9]|REL_).*\$"
	do
		git branch -r | tr -d \ | grep -E "$i" --color=never | tail $limit
	done #List latest RC and tags
}

function get_svn_branch()
{
	# git-ref
	[ $# -gt 0 ] || set -- HEAD
	
	local svn_remote="$(git config --get-regexp svn-remote.*\.url | cut -d' ' -f1 | sed 's#\.url$##')"
	if [ -z "$svn_remote" ]
	then
		for i do
			echo "@{upstream}"
		done
		return
	fi
	
	for i in $svn_remote
	do
		svn_url_pattern+="|$(
			git config $i.url
		)/?$(
			git config $i.fetch | cut -d: -f1 | sed 's#trunk##'
		)"
	done
	svn_url_pattern="${svn_url_pattern#?}"
	
	for i in $@
	do
		git log -1 --pretty=format:"%s%n%b" --first-parent --grep=git-svn-id $i |
			grep git-svn-id |
			cut -d' ' -f2 |
			sed $sedRegExp "{
				s#$svn_url_pattern##
				s#@.*##
				s/^$/${GIT_SVN_ID:-git-svn}/
			}"
	done
}

function get_git_svn_branch()
{
	get_svn_branch $@ | sed 's#^branches/##'
}

function active_branch_from_log()
{
	case $1 in
		[0-9]*) count=$1;;
		*) count=20;;
	esac
	
	git log --all --pretty=format:"%d" |
		tr "(,)" " " |
		xargs printf "%s\n" |
		grep -vE "^$(
			git remote | implode "/|^"
		)/|^$(
			git branch | tr -d \*\ | implode "|^"
		)|^HEAD|^refs/stash" |
		head -$count
}

function svn_branch_log()
{
	COUNT=0
	for i do
		if [ $COUNT -eq 0 ] && [ "${i:0:1}" != "-" ]
		then
			COUNT=$(($COUNT + 1))
			REF="$i"
		elif [ $COUNT -gt 0 ] && [ "${i:0:1}" != "-" ]
		then
			error "Only one branch ref allowed!"
		else
			ARGS="$ARGS $i"
		fi
	done
	set -- $ARGS

	#####
	# List total new commits in specified ref
	#
	git log --first-parent --pretty=format:"%s%n%b" $REF |
		grep git-svn-id |
		grep -v $(get_git_svn_branch $REF) |
		head -1 |
		grep -oE "@[0-9]+" |
		xargs git log --all --pretty=format:%h --grep |
		xargs printf "%s..$REF " |
		xargs git lg --first-parent $@
}

function non_release_jira()
{
	jira-cli --oneline WTF-1 #> /dev/null 2>&1

	#####
	# Find non-release jiras from all branches
	#
	for i in $(
		git branch -r | tr -d \ | grep -E "[A-Z]+\-[0-9]+" --color=never | grep -vE "^$(
			git remote | implode "/|^"
		)/"
	)
	do
		git log --pretty=format:"%at $i %an $(git config url.jira)/browse/$(
			echo $i | grep -oE "[A-Z]+\-[0-9]+" --color=never
		) $(
			jira-cli $(
				echo $i | grep -oE "[A-Z]+\-[0-9]+" --color=never | grep -v QAT
			) --format="[%status]" | tr " " _
		)%n" -1 $i
	done | column -t | sort -rn | grep -v '\[Closed\]' | grep -v '\[Open\]'

	#####	
	# Find non-release jiras from maintenance branch
	#
	time for i in $(
		git reflog $(
			git branch -r | tr -d \ | grep ^maintenance_2012 --color=never | tail -1
		) | cut -d " " -f 1
	)
	do 
		git log -1 --pretty=format:"%s" $i | grep -oE "[A-Z]+\-[0-9]+" --color=never
	done | sort -u | xargs jira-cli --oneline | grep -v Closed
}

function set_remote()
{
	remote=$1
	if [ $(git remote | grep -c ^$remote$) -eq 0 ]
	then
		echo "Remote $remote does not exist in your git config"
		exit 1
	fi
}

function push_remote()
{
	set_remote $1
	
	[ -d ~/mig33/Scripts ] || error "Missing resource ~/mig33/Scripts"
	
	echo
	echo "Pushing new SVN branches to remote..."
	echo
	branches_to_push=$(missing_remote_branches $remote ${2:-20})
	# all_branches=$(git branch -r | tr -d \ | grep -v ^$(git remote | implode "|"))
	for i in $branches_to_push
	do
		echo master:$i
	done | xargs git push $remote
	for i in $branches_to_push
	do
		echo $i:$i
	done | xargs git push -f $remote trunk:master
	
	echo
	echo "Updating remote..."
	echo
	for i in $(active_branch_from_log)
	do
		echo "refs/remotes/$i:$i"
	done | xargs git push $remote
}

SVN_URL="$(git config url.svn)/%s"
GIT_URL="$(git config url.git-svn)/%s.git"
REMOTE_ORIGIN=mig33
function init_git_svn_repo()
{
	case $2 in
		'') error "Repository name required, e.g. login.mig33.com";;
		*)  repo_name=$2;;
	esac
	case $3 in
		'') git_repo_name=$(echo $repo_name | tr '.' '_');;
		*)  git_repo_name=$3;;
	esac
	case $1 in
		clone)
			mkdir $repo_name
			cd $repo_name;;
		init) ;;
		*) error "Clone or init only..."
	esac
	
	git svn init --stdlayout "$(printf $SVN_URL $repo_name)"
	git remote add $REMOTE_ORIGIN "$(printf $GIT_URL $git_repo_name)"
	git fetch $REMOTE_ORIGIN
	git reset --hard $REMOTE_ORIGIN/trunk
	git svn info
}

function missing_remote_branches()
{
	set_remote $1
	
	#####
	# list of SVN branches that are not available on gitorious
	#
	for i in $(active_branch_from_log $2)
	do
		if [ $(git branch -r | tr -d \ | grep -cE "^$remote/$i\$") -eq 0 ]
		then
			echo $i
		fi
	done
}	

function delete_non_svn_branches_from_remote()
{
	set_remote $1
	
	#####
	# delete gitorious merge branches
	#
	git branch -r | tr -d \ |
		grep -E "^$remote/" --color=never |
		sed "s#^$remote/##" |
		grep -vE "^$(
			git branch -r | tr -d \ |
				grep -vE "^$(
					git remote | implode "/|^"
				)/" | implode "|^"
			)" |
		grep -v master |
		xargs git push --delete $remote
}

function create_rc()
{
	case $1 in
		'') RC_BRANCH=$(latest_rc_tags | grep _RC --color=never);;
		new)
			shift;
			#[ $# -ge 1 ] || error "Missing argument QAT JIRA"
			i=$(latest_rc_tags | grep RC | grep -oE '\.[0-9]+' --color=never | tr -d \.)
			RC_BRANCH=$(latest_rc_tags | grep RC | sed "s#$i#$((1+$i))#")
			[ $(echo $1 | grep -cE '[A-Z]+\-[0-9]+') -eq 1 ] || error "Invalid QAT number"
			git config release.jira $1
			JIRA="$(git config release.jira)";
			echo "git checkout master"
			echo "git reset --hard trunk"
			echo "git svn branch $RC_BRANCH -m \"$JIRA: new RC branches/$RC_BRANCH\""
			error "Command not completed yet";;
		REL_[0-9.]*_RC) RC_BRANCH="$1"; shift;;
		*) error "the given/current RC branch does not follow RC convention (e.g. REL_*_RC): $RC_BRANCH";;
	esac
	
	RC_NUMBER=$(echo $RC_BRANCH | grep -oE '[0-9\.]+' --color=never | sed 's#\.##')
	
	if [ $(echo $RC_BRANCH | grep -c -E '^REL_[0-9\.]+_RC$') -lt 1 ]
	then
		error "the given/current RC branch does not follow RC convention (e.g. REL_*_RC): $RC_BRANCH"
	elif [ $(git branch -a | grep -c $RC_BRANCH) -lt 1 ]
	then
		error "the given RC branch does not exist in your git index,
		run
			git svn rebase --all
		or
		run (from trunk)
			git svn branch $RC_BRANCH -m 'JIRA: new branches/$RC_BRANCH'"
	fi
	
	if [ $(git branch | grep -c rel$RC_NUMBER) -lt 1 ]
	then
		git checkout $RC_BRANCH -b rel$RC_NUMBER
	else
		git checkout rel$RC_NUMBER
	fi
	
	git branch -D mqa$RC_NUMBER
	git checkout $RC_BRANCH -b mqa$RC_NUMBER
}

function create_tag()
{
	case $1 in
		REL_*) TAG="$1";;
		*) read -p "Please enter SVN tag name [$(latest_rc_tags | grep tags | cut -d/ -f2)]: " TAG;;
	esac
	command="git svn tag $TAG -m '$(git config release.jira): tags/$TAG'"
	echo $command
}

function rebase_trunk()
{
	[ $(git mig33 upstream HEAD) = "trunk" ] &&
		MERGE_FROM=$(latest_rc_tags | grep RC) ||
		MERGE_FROM="--no-jira master"
	
	git qa merge $MERGE_FROM $(git config release.jira) post release $(latest_rc_tags | grep tags)
}

function show_non_dcommit_hashes()
{
	git rev-list --reverse --first-parent $(get_git_svn_branch $1)..$1
}

function show_log()
{
	args=$(getopt :d:hj $*)
	set -- $args
	for i do
		case "$1" in
			-d) shift; unpushed=$(show_non_dcommit_hashes $1); shift;;
			-h) hashonly="--pretty=format:%h"; shift;;
			-j) jiraonly="--pretty=format:%s%n%b"; shift;;
			--) shift; break;;
		esac
	done
	
	if [ -n "$jiraonly" ] && [ -n "$hashonly" ]
	then
		hash2jira $@ $unpushed
	elif [ -n "$jiraonly" ]
	then
		git show --relative="#" $@ $hashonly $jiraonly $unpushed | _listjira | grep -v QAT | xargs echo
	else
		git show --relative="#" $@ $hashonly $jiraonly $unpushed
	fi
}

function _listjira()
{
	grep -oE "[A-Z]+\-[0-9]+" --color=never | sort -u
}

function hash2jira()
{
	for i in $@
	do
		git show $i --relative="#" --pretty=format:"%h $(
			git svn find-rev $i | sed 's#\([0-9][0-9]*\)#r\1#'
		) $(
			git show $i --pretty=format:"%s%n%b" --shortstat | _listjira | grep -v QAT | xargs echo
		)" | grep -v ^$
	done
}

function blame_during_merge_conflicts()
{
	for i in $(git diff --name-only | uniq)
	do
		hashes=$(git log --merge --pretty=format:"%h" $i)
		for b in $(get_git_svn_branch $hashes | uniq)
		do
			echo $i $(
				git log -1 $b --pretty=format:"%an"
			) $b:$(
				for h in $hashes
				do
					[ $(git show --pretty=format:"%s%n%b" --shortstat $h | grep -c "$b") -gt 0 ] &&
					git svn find-rev $h | xargs printf "r%s\n"
				done | implode ','
			)
		done
	done | column -t
}

function show_graph()
{
	git log --all --pretty=format:"%d" |
		tr "(,)" " " |
		xargs printf "%s\n" |
		grep -E "^(tags/)?([0-9]|REL_)" --color=never |
		git log --stdin --graph --decorate --pretty=format:"%d" $@ trunk
		# | grep -v '*[^(]*$' | less
}

function jira_release_tracking()
{
	for i in $@
	do
		if [ -n "$(git lg --grep=$i)" ]
		then
			echo $i merged or exist in this tree
		elif [ $(git branch -r | grep -c $i) -eq 0 ] ||
			[ -n "$(
				git branch | grep mqa --color=never |
					tr -d " *" | xargs printf "^%s\n" |
					git lg --stdin --all --grep=$i ^$(git branch -a | grep remotes/[^/]*$i --color=never | tr -d ' ') HEAD
			)" ]
		then
			jira-cli --oneline $i
			# git lg --all --grep=$i
			for h in $(git rev-list --all --grep=$i)
			do
				git log -1 --format="%h %an $(
					git mig33 upstream $h
				)($(
					git branch --contains $h | tr -d ' '
				)) $(
					git svn find-rev $h | xargs printf 'r%s'
				)" $h
			done | column -t
			exit
		else
			if [ -z "$(git config release.jira)" ]
			then
				error "release.jira doesn't exist, try:
				git config release.jira QAT-XXX"
			fi
			echo git qa merge $(git branch -a | grep remotes/[^/]*$i --color=never | tr -d ' ') $(git config release.jira) mergeQA
		fi
	done
}

function show_branch_status
{
	#####
	# unpushed local branches
	#
	( echo branch ref upstream uncommitted
	for i in $(git branch | tr -d "* ")
	do
		git rev-list --left-right --count $(get_git_svn_branch $i)...$i |
			xargs echo $(git log -1 --pretty=format:"$i %h" $i)
	done ) | column -t
}

function generate_trac_link()
{
	for i
	do
		git svn find-rev $i | xargs printf "$(git config url.trac)/changeset/%s\n"
	done
}

function error()
{
	if [ -n "$1" ]
	then
		echo "Error: $1"
		echo
	fi
	echo "Usage: git mig33 -h|help|?"
	echo "Usage: git mig33 edit|-e|eclipse                 # edit this script"
#	echo "Usage: git mig33 clone|init [repo_name]          # clone git svn repo"
	echo "Usage: git mig33 branch [info] <limit>           # list SVN branches sorted by last updated"
#	echo "Usage: git mig33 remote cleanup <remote>         # reverse prune, deletes remote non SVN branch"
#	echo "Usage: git mig33 remote missing <remote>         # SVN branches missing from remote"
	echo "Usage: git mig33 show [-dhj]                     # -d:unpushed -h:hash-only -j:jira-only"
	echo
	echo "Usage: git qa info [-limit]                      # list last RC tags or maintenance branch"
	echo "Usage: git qa graph [-limit]                     # show QA graph"
	echo "Usage: git qa unmerged [JIRA#..]                 # release jira tracking, whether a jira has been merged or release"
	echo "Usage: git qa merge <branchname> <JIRA#> [message]"
	echo "Usage: git qa blame                              # run a different variation of git log --merge"
#	echo "Usage: git qa push|dcommit <remote>              # Please do not use this!!! update local SVN to remote"
	echo
	echo "Deprecated commands:"
	echo "Usage: git mig33 log [branch]                    # log of current SVN branch"
	echo "Usage: git qa rc [new [QAT]]"                    # Create new SVN branch
	echo "Usage: git qa tag [REL_8.XX]"                    # Generate create new SVN tag command
	echo "Usage: git qa rebase"                            # Run git qa merge to rebase from RC
	exit
}

case $1 in
	''|-h|help|?)         error;;
	edit|-e)              vim $0;;
	eclipse)              open -a /Applications/eclipse_indigo/Eclipse.app/ $0;;
	branch)
		shift; case $1 in
			--unpushed|status)   shift; show_branch_status $@;;
			*)            active_branch_from_log $@;;
		esac;;
	upstream)             shift; get_git_svn_branch $@;;
	info|release)         shift; latest_rc_tags $@;;
	tag|tags|rc)          error;; #reserved
	clone|init)           init_git_svn_repo $@;;
	remote)
		shift; case $1 in
			cleanup)      shift; delete_non_svn_branches_from_remote $@;;# Destructive
			missing)      shift; missing_remote_branches $@;;
		esac;;
	show)                 shift; show_log $@;;
	log)                  shift; svn_branch_log $@;;
	scp)				  shift; gitwebscp $@;;
	rebase)				  shift; gitsvnrebase $@;;
	trac)                 shift; generate_trac_link $@;;
	qa)
		shift; case $1 in
			unmerged)
				shift; case $1 in
					'') non_release_jira;;
					*)  jira_release_tracking $@;;
				esac;;
			graph)        shift; show_graph $@;;
			merge)        shift; gitsvnmerge $@;;
			blame)        shift; blame_during_merge_conflicts $@;;
			push|dcommit) shift; push_remote $@;;
			rc)           shift; create_rc $@;;# Destructive
			tag)          shift; create_tag $@;;# Destructive
			rebase)       shift; rebase_trunk $@;;# Destructive
			*)            git mig33 $@;; #error;;
		esac;;
	*)                    git svn $@;; #error;;
esac;
