#!/bin/bash

function latest_rc_tags()
{
	case $1 in
		-[0-9]*) limit=$1;;
		[0-9]*) limit=-$1;;
		*)      limit=-1;;
	esac
	for i in "^maintenance_2012.." "^REL_.*_RC\$" "^tags/([0-9]|REL_).*\$"
	do
		git branch -r | tr -d \ | grep -E "$i" --color=never | tail $limit
	done #List latest RC and tags
}

function active_branch_from_log()
{
	case $1 in
		[0-9]*) count=$1;;
		*) count=20;;
	esac
	
	git log --all --format="%d" |
		sed -E "s#\(|,|\)##g" |
		xargs printf "%s\n" |
		grep -vE "^$(
			git remote | implode "/|^"
		)/|^$(
			git branch | tr -d \*\ | implode "|^"
		)|^HEAD|^refs/stash" |
		head -$count
}

function reflog()
{
	#WIP
	git lg --first-parent --since="$(
		git log -1 --pretty=format:"%ad" $(
			git reflog $(
				git svn info | grep URL | grep -oE "(tags/)?[^/]+\$" --color=never
				) | cut -d " " -f 1 | tail -1
			)
		)" #List total new commits in maintenance branch
}

function non_release_jira()
{
	jira-cli --oneline WTF-1 #> /dev/null 2>&1

	#####
	# Find non-release jiras from all branches
	#
	for i in $(
		git branch -r | tr -d \ | grep -E "[A-Z]+\-[0-9]+" --color=never | grep -vE "^$(
			git remote | implode "/|^"
		)/"
	)
	do
		git log --pretty=format:"%at $i %an $(git config url.jira)/browse/$(
			echo $i | grep -oE "[A-Z]+\-[0-9]+" --color=never
		) $(
			jira-cli $(
				echo $i | grep -oE "[A-Z]+\-[0-9]+" --color=never | grep -v QAT
			) --format="[%status]" | tr " " _
		)%n" -1 $i
	done | column -t | sort -rn | grep -v '\[Closed\]' | grep -v '\[Open\]'

	#####	
	# Find non-release jiras from maintenance branch
	#
	time for i in $(
		git reflog $(
			git branch -r | tr -d \ | grep ^maintenance_2012 --color=never | tail -1
		) | cut -d " " -f 1
	)
	do 
		git log -1 --pretty=format:"%s" $i | grep -oE "[A-Z]+\-[0-9]+" --color=never
	done | sort -u | xargs jira-cli --oneline | grep -v Closed
}

function set_remote()
{
	remote=$1
	if [ $(git remote | grep -c ^$remote$) -eq 0 ]
	then
		echo "Remote $remote does not exist in your git config"
		exit
	fi
}

function push_remote()
{
	set_remote $1
	
	[ -d ~/mig33/Scripts ] || error "Missing resource ~/mig33/Scripts"
	
	echo
	echo "Pushing new SVN branches to remote..."
	echo
	branches_to_push=$(missing_remote_branches $remote)
	# all_branches=$(git branch -r | tr -d \ | grep -v ^$(git remote | implode "|"))
	for i in $branches_to_push
	do
		echo master:$i
	done | xargs git push $remote
	for i in $branches_to_push
	do
		echo $i:$i
	done | xargs git push $remote -f trunk:master
	
	echo
	echo "Updating remote..."
	echo
	for i in $(active_branch_from_log)
	do
		echo "refs/remotes/$i:$i"
	done | xargs git push $remote
}

SVN_URL="$(git config url.svn)/%s"
GIT_URL="$(git config url.git-svn)/%s.git"
REMOTE_ORIGIN=mig33
function init_git_svn_repo()
{
	case $2 in
		'') error "Repository name required, e.g. login.mig33.com";;
		*)  repo_name=$2;;
	esac
	case $3 in
		'') git_repo_name=$(echo $repo_name | tr '.' '_');;
		*)  git_repo_name=$3;;
	esac
	case $1 in
		clone)
			mkdir $repo_name
			cd $repo_name;;
		init) ;;
		*) error "Clone or init only..."
	esac
	
	git svn init --stdlayout "$(printf $SVN_URL $repo_name)"
	git remote add $REMOTE_ORIGIN "$(printf $GIT_URL $git_repo_name)"
	git fetch $REMOTE_ORIGIN
	git reset --hard $REMOTE_ORIGIN/trunk
	git svn info
}

function missing_remote_branches()
{
	set_remote $1
	
	#####
	# list of SVN branches that are not available on gitorious
	#
	for i in $(active_branch_from_log $2)
	do
		if [ $(git branch -r | tr -d \ | grep -cE "^$remote/$i\$") -eq 0 ]
		then
			echo $i
		fi
	done
}	

function delete_non_svn_branches_from_remote()
{
	set_remote $1
	
	#####
	# delete gitorious merge branches
	#
	git branch -r | tr -d \ |
		grep -E "^$remote/" --color=never |
		sed -E "s#^$remote/##" |
		grep -vE "^$(
			git branch -r | tr -d \ |
				grep -vE "^$(
					git remote | implode "/|^"
				)/" | implode "|^"
			)" |
		grep -v master |
		xargs git push --delete $remote
}

function create_rc()
{
	case $1 in
		'') RC_BRANCH=$(latest_rc_tags | grep _RC --color=never);;
		new)
			shift;
			[ $# -ge 1 ] || error "Missing argument RC_BRANCH and JIRA"
			i=$(latest_rc_tags | grep RC | grep -oE '\.[0-9]+' --color=never | tr -d \.)
			RC_BRANCH=$(latest_rc_tags | grep RC | sed "s#$i#$((1+$i))#")
			JIRA="$1";
			echo "git checkout master"
			echo "git reset --hard trunk"
			echo "git svn branch $RC_BRANCH -m \"$JIRA: new RC branches/$RC_BRANCH\""
			error "Command not completed yet";;
		REL_[0-9.]*_RC) RC_BRANCH="$1"; shift;;
		*) error "the given/current RC branch does not follow RC convention (e.g. REL_*_RC): $RC_BRANCH";;
	esac
	
	RC_NUMBER=$(echo $RC_BRANCH | grep -oE '[0-9\.]+' --color=never | sed 's#\.##')
	
	if [ $(echo $RC_BRANCH | grep -c -E '^REL_[0-9\.]+_RC$') -lt 1 ]
	then
		error "the given/current RC branch does not follow RC convention (e.g. REL_*_RC): $RC_BRANCH"
	elif [ $(git branch -a | grep -c $RC_BRANCH) -lt 1 ]
	then
		error "the given RC branch does not exist in your git index,
		run
			git svn rebase --all
		or
		run (from trunk)
			git svn branch $RC_BRANCH -m 'JIRA: new branches/$RC_BRANCH'"
	fi
	
	if [ $(git branch | grep -c rel$RC_NUMBER) -lt 1 ]
	then
		git checkout $RC_BRANCH -b rel$RC_NUMBER
	else
		git checkout rel$RC_NUMBER
	fi
	
	git branch -D mergeQA_$RC_NUMBER
	git checkout $RC_BRANCH -b mergeQA_$RC_NUMBER
}

function show_non_dcommit_hashes()
{
	git svn dcommit --dry-run | grep diff | tr " " "\n" | grep -v diff | grep -v "~"
}

function show_log()
{
	args=$(getopt :dhj $*)
	set -- $args
	for i do
		case "$1" in
			-d) unpushed=$(show_non_dcommit_hashes); shift;;
			-h) hashonly="--pretty=format:%h"; shift;;
			-j) jiraonly="--pretty=format:%B"; shift;;
			--) shift; break;;
		esac
	done
	
	if [ -n "$jiraonly" ] && [ -n "$hashonly" ]
	then
		hash2jira $@ $unpushed
	elif [ -n "$jiraonly" ]
	then
		git show --relative="#" $@ $hashonly $jiraonly $unpushed | _listjira | xargs echo
	else
		git show --relative="#" $@ $hashonly $jiraonly $unpushed
	fi
}

function _listjira()
{
	grep -oE "[A-Z]+\-[0-9]+" --color=never |
		grep -v QAT |
		sort -u
}

function _listjiraQAT()
{
	grep -oE "[A-Z]+\-[0-9]+" --color=never |
		sort -u
}

function hash2jira()
{
	for i in $@
	do
		git show $i --relative="#" --format="%h $(
			git svn find-rev $i
		) $(
			git show $i --format=%B --shortstat | _listjira | xargs echo
		)" | grep -v ^$
	done
}

function blame_during_merge_conflicts()
{
	if [ -n "$1" ] && ! [ $1 -ge 0 2>/dev/null ] && [ $(git branch -a | grep -c $1) -gt 0 ]
	then
		LAST_MERGE=$1
		shift
	else
		LAST_MERGE=$(git config mergeQA.$(git name-rev --name-only HEAD).last)
	fi
	
	case $1 in
		[0-9]*) limit=$1;;
		*)      limit=1;;
	esac
	
	for i in $(git diff --name-only | uniq)
	do
		 list_head=($(git log -$limit --pretty=format:"%h" HEAD        $i))
		list_merge=($(git log -$limit --pretty=format:"%h" $LAST_MERGE $i))
		
		count=0
		until [ $count -eq $limit ] || [ $count -eq ${#list_head[@]} ] || [ $count -eq ${#list_merge[@]} ]
		do
			echo $i $(
				git log -1 --pretty=format:"%an@HEAD:$(
					git log -1 --pretty=format:"%B" ${list_head[$count]} |
						_listjiraQAT |
						implode ","
				) " ${list_head[$count]}
			) $(
				git log -1 --pretty=format:"%an@$LAST_MERGE:$(
					git log -1 --pretty=format:"%B" ${list_merge[$count]} |
						_listjiraQAT |
						implode ","
				) " ${list_merge[$count]}
			)
			count=$(($count + 1))
		done
	done | column -t
}

function show_graph()
{
	git log --graph --decorate --format=%d $@ $(
		git log --all --format="%d" |
			sed -E "s#\(|,|\)##g" |
			xargs printf "%s\n" |
			grep -E "^(tags/)?([0-9]|REL_)" --color=never
	) trunk
}

function jira_release_tracking()
{
	for i in $@
	do
		if [ -n "$(git lg --grep $i)" ]
		then
			echo $i merged or exist in this tree
		elif [ $(git branch -r | grep -c $i) -eq 0 ] ||
			[ -n "$(git lg --all ^$i HEAD $(
				git branch | grep mergeQA --color=never | tr -d " *" | xargs printf "^%s\n"
			) --grep $i)" ]
		then
			jira-cli --oneline $i
			git lg --all --grep $i
		else
			if [ -z "$(git config release.jira)" ]
			then
				error "release.jira doesn't exist, try:
				git config --add release.jira QAT-XXX"
			fi
			echo git qa merge $i $(git config release.jira) mergeQA
		fi
	done
}

function error()
{
	if [ -n "$1" ]
	then
		echo "Error: $1"
		echo
	fi
	echo "Usage: git mig33 -h|help|?"
	echo "Usage: git mig33 edit|-e|eclipse                 # edit this script"
#	echo "Usage: git mig33 clone|init [repo_name]          # clone git svn repo"
	echo "Usage: git mig33 branch [info] <limit>           # list SVN branches sorted by last updated"
	echo "Usage: git mig33 remote cleanup <remote>         # reverse prune, deletes remote non SVN branch"
	echo "Usage: git mig33 remote missing <remote>         # SVN branches missing from remote"
	echo "Usage: git mig33 show [-dhj]                     # -d:unpushed -h:hash-only -j:jira-only"
	echo
	echo "Usage: git qa info                               # list last RC tags or maintenance branch"
	echo "Usage: git qa graph [-limit]                     # show QA graph"
	echo "Usage: git qa unmerged [JIRA#..]                 # release jira tracking, whether a jira has been merged or release"
	echo "Usage: git qa merge <branchname> <JIRA#> [message]"
	echo "Usage: git qa blame [branch] [limit=1]"
	echo "Usage: git qa push|dcommit <remote>              # Please do not use this!!! update local SVN to remote"
	echo
	echo "Deprecated or useless commands:"
	echo "Usage: git mig33 reflog                          # log of current SVN branch"
	echo "Usage: git qa rc [new [QAT]]"
	exit
}

case $1 in
	''|-h|help|?)         error;;
	edit|-e)              vim $0;;
	eclipse)              open -a /Applications/eclipse_indigo/Eclipse.app/ $0;;
	branch)
		shift; case $1 in
			info|last|latest|release|tags|rc|maintenance)
			              shift; latest_rc_tags $@;;
			*)            active_branch_from_log $@;;
		esac;;
	info|release)         shift; latest_rc_tags $@;;
	tag|tags|rc)          error;; #reserved
	clone|init)           init_git_svn_repo $@;;
	remote)
		shift; case $1 in
			cleanup)      shift; delete_non_svn_branches_from_remote $@;;# Destructive
			missing)      shift; missing_remote_branches $@;;
		esac;;
	show)                 shift; show_log $@;;
	reflog)               shift; reflog $@;;
	scp)				  shift; gitwebscp $@;;
	rebase)				  shift; gitsvnrebase $@;;
	qa)
		shift; case $1 in
			unmerged)
				shift; case $1 in
					'') non_release_jira;;
					*)  jira_release_tracking $@;;
				esac;;
			graph)        shift; show_graph $@;;
			merge)        shift; gitsvnmerge $@;;
			blame)        shift; blame_during_merge_conflicts $@;;
			push|dcommit) shift; push_remote $@;;
			rc)           shift; create_rc $@;;# Destructive
			*)            git mig33 $@;; #error;;
		esac;;
	*)                    git svn $@;; #error;;
esac;
